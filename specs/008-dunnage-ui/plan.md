# Implementation Plan: Dunnage Wizard Workflow UI

**Branch**: `008-dunnage-ui` | **Date**: December 27, 2025 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/008-dunnage-ui/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command following Speckit methodology.

## Summary

Create a complete wizard workflow UI for guided dunnage receiving in the MTM Receiving Application. Implements strict MVVM pattern with compile-time bindings (`x:Bind`). Each workflow step (Mode Selection → Type Selection → Part Selection → Quantity Entry → Details Entry → Review & Save) is a separate UserControl with dedicated ViewModel, coordinated by a main orchestrator (DunnageWorkflowViewModel). Includes three modes: Guided Wizard, Manual Entry (bulk grid), and Edit Mode (historical data). Features dynamic spec input generation based on type schemas, inventory notification for Visual-tracked parts, pagination for type selection, and default mode preferences for efficiency.

## Technical Context

**Language/Version**: C# 12, .NET 8.0
**Primary Dependencies**: WinUI 3 (Windows App SDK 1.8+), CommunityToolkit.Mvvm 8.2+, CommunityToolkit.WinUI.UI.Controls 7.1+
**Storage**: MySQL 8.0+ (mtm_receiving_application) for wizard data; SQL Server (Infor Visual MTMFG) READ-ONLY for part/PO validation
**Testing**: xUnit with Moq for ViewModels/Services; manual UI testing for Views
**Target Platform**: Windows 10 1809+ / Windows 11 (x64)
**Project Type**: Desktop WinUI 3 application (existing multi-project solution)
**Performance Goals**: <500ms for database operations, <2 seconds for type/part list loading, 60fps UI responsiveness
**Constraints**: MySQL 5.7.24 compatibility (NO JSON functions, CTEs, window functions); Infor Visual READ-ONLY (ApplicationIntent=ReadOnly); strict MVVM separation (no ViewModel→DAO)
**Scale/Scope**: 15 new XAML files (6 wizard steps × 2 files + 3 mode views), 15 ViewModels, ~3,000 LOC, integration with existing IService_DunnageWorkflow, IService_MySQL_Dunnage, IService_DunnageCSVWriter services

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify alignment with [MTM Receiving Application Constitution](../../.specify/memory/constitution.md) v1.2.1.

### Core Principles Alignment

- [x] **I. MVVM Architecture**: Plan separates ViewModels (15 total), Views (XAML only), Models, and Services with strict layer separation
- [x] **II. Database Layer**: All services use Model_Dao_Result pattern from existing DAOs, MySQL stored procedures only, async operations
- [x] **III. Dependency Injection**: All new ViewModels registered as Transient in App.xaml.cs, inject existing services (IService_DunnageWorkflow, IService_MySQL_Dunnage, IService_DunnageCSVWriter, IService_UserPreferences, IService_ErrorHandler, ILoggingService)
- [x] **IV. Error Handling & Logging**: All ViewModels use IService_ErrorHandler for user-facing errors, ILoggingService for audit trail
- [x] **V. Security & Authentication**: Uses existing session management, no new authentication requirements
- [x] **VI. WinUI 3 Modern Practices**: All views use x:Bind (compile-time binding), ObservableCollection, CommunityToolkit.Mvvm ([ObservableProperty], [RelayCommand], partial classes), async/await
- [x] **VII. Specification-Driven**: This plan follows Speckit workflow with spec.md → plan.md → research.md → data-model.md → contracts → tasks.md

### Technology Constraints

- [x] **Platform**: Windows 10/11, .NET 8.0, WinUI 3 (Windows App SDK 1.8+) - matches existing platform
- [x] **Database**: MySQL for wizard session data (uses existing `mtm_receiving_application` database), SQL Server for Infor Visual part/PO lookup (READ ONLY)
- [x] **MySQL 5.7.24 Compatible**: NO new database schema changes required - uses existing tables from 007-architecture-compliance
- [x] **Required Packages**: CommunityToolkit.Mvvm 8.2+, MySql.Data 9.0+, Microsoft.Data.SqlClient 5.2+ - already installed

### Critical Constraints

- [x] **Infor Visual READ ONLY**: Feature queries Infor Visual for part/PO data via existing Dao_InforVisualPart, Dao_InforVisualPO:
  - [x] Connection uses ApplicationIntent=ReadOnly (enforced in existing DAO constructors)
  - [x] Only SELECT queries via stored procedures (existing pattern)
  - [x] No INSERT, UPDATE, DELETE, or DDL operations (READ-ONLY enforced)
  - [x] Graceful handling of connection failures (existing DAOs implement fallback logic)
- [x] **Forbidden Practices**: 
  - [x] No direct SQL (uses existing DAOs via Services)
  - [x] No DAO exceptions (all return Model_Dao_Result)
  - [x] No logic in code-behind (ViewModels only have `InitializeComponent()`)
  - [x] No service locator (constructor injection via DI)
  - [x] No ViewModel→DAO violations (all access flows through Services)

### Justification for Violations

**No violations of constitutional principles.** This feature strictly adheres to all established patterns from the Receiving workflow UI (matching reference implementation).

## Project Structure

### Documentation (this feature)

```text
specs/008-dunnage-ui/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output - technical decisions on pagination, dynamic controls, etc.
├── data-model.md        # Phase 1 output - No new database schema (uses existing from 007)
├── quickstart.md        # Phase 1 output - Developer setup and build instructions
├── contracts/           # Phase 1 output - ViewModel command/property contracts for consistency
└── mockups/             # HTML/CSS/JS visual design reference (existing)
    ├── index.html
    ├── pages/
    ├── css/
    └── js/
```

### Source Code (repository root)

```text
MTM_Receiving_Application/
├── Views/
│   ├── Main/                              # Main navigation pages (EXISTING FOLDER)
│   │   └── Main_DunnageLabelPage.xaml     # ✅ ALREADY EXISTS - Main orchestrator page
│   │       Main_DunnageLabelPage.xaml.cs  # ✅ ALREADY EXISTS - Code-behind
│   └── Dunnage/                           # Dunnage workflow step views (EMPTY FOLDER)
│       ├── Dunnage_ModeSelectionView.xaml          # NEW - Mode selection cards
│       ├── Dunnage_ModeSelectionView.xaml.cs       # NEW
│       ├── Dunnage_TypeSelectionView.xaml          # NEW - Type grid with pagination
│       ├── Dunnage_TypeSelectionView.xaml.cs       # NEW
│       ├── Dunnage_PartSelectionView.xaml          # NEW - Part dropdown + inventory notification
│       ├── Dunnage_PartSelectionView.xaml.cs       # NEW
│       ├── Dunnage_QuantityEntryView.xaml          # NEW - Quantity NumberBox
│       ├── Dunnage_QuantityEntryView.xaml.cs       # NEW
│       ├── Dunnage_DetailsEntryView.xaml           # NEW - PO, Location, dynamic spec inputs
│       ├── Dunnage_DetailsEntryView.xaml.cs        # NEW
│       ├── Dunnage_ReviewView.xaml                 # NEW - DataGrid + Save/Add Another
│       ├── Dunnage_ReviewView.xaml.cs              # NEW
│       ├── Dunnage_ManualEntryView.xaml            # NEW - Grid-based bulk entry mode
│       ├── Dunnage_ManualEntryView.xaml.cs         # NEW
│       ├── Dunnage_EditModeView.xaml               # NEW - Historical data editing mode
│       └── Dunnage_EditModeView.xaml.cs            # NEW
├── ViewModels/
│   ├── Main/                              # Main page ViewModels (EXISTING FOLDER)
│   │   └── Main_DunnageLabelViewModel.cs  # ✅ ALREADY EXISTS - Orchestrator ViewModel
│   └── Dunnage/                           # Dunnage step ViewModels (EMPTY FOLDER)
│       ├── Dunnage_ModeSelectionViewModel.cs       # NEW
│       ├── Dunnage_TypeSelectionViewModel.cs       # NEW
│       ├── Dunnage_PartSelectionViewModel.cs       # NEW
│       ├── Dunnage_QuantityEntryViewModel.cs       # NEW
│       ├── Dunnage_DetailsEntryViewModel.cs        # NEW
│       ├── Dunnage_ReviewViewModel.cs              # NEW
│       ├── Dunnage_ManualEntryViewModel.cs         # NEW
│       └── Dunnage_EditModeViewModel.cs            # NEW
├── Services/                              # ✅ ALL ALREADY EXIST (NO NEW FILES)
│   ├── Database/
│   │   └── Service_MySQL_Dunnage.cs       # ✅ ALREADY EXISTS (database operations)
│   └── Receiving/
│       ├── Service_DunnageWorkflow.cs     # ✅ ALREADY EXISTS (session management)
│       └── Service_DunnageCSVWriter.cs    # ✅ ALREADY EXISTS (CSV export)
├── Data/                                  # ✅ ALL ALREADY EXIST (NO NEW FILES)
│   └── Dunnage/
│       ├── Dao_DunnageType.cs             # ✅ ALREADY EXISTS
│       ├── Dao_DunnagePart.cs             # ✅ ALREADY EXISTS
│       └── Dao_DunnageLoad.cs             # ✅ ALREADY EXISTS
├── Models/                                # ✅ ALL ALREADY EXIST (NO NEW FILES)
│   └── Dunnage/
│       ├── Model_DunnageType.cs           # ✅ ALREADY EXISTS
│       ├── Model_DunnagePart.cs           # ✅ ALREADY EXISTS
│       └── Model_DunnageLoad.cs           # ✅ ALREADY EXISTS
└── App.xaml.cs                            # MODIFY - DI registration for new ViewModels

```

**Structure Decision**: This is an extension of an existing desktop WinUI 3 application following established naming conventions:
- **Main pages** in `Views/Main/` with prefix `Main_` (e.g., `Main_DunnageLabelPage.xaml`) - orchestrator already exists
- **Step views** in `Views/Dunnage/` with prefix `Dunnage_` (e.g., `Dunnage_ModeSelectionView.xaml`) - folder exists but is empty
- **Main ViewModels** in `ViewModels/Main/` with prefix `Main_` - orchestrator already exists  
- **Step ViewModels** in `ViewModels/Dunnage/` with prefix `Dunnage_` - folder exists but is empty
- Matches existing pattern from Receiving workflow: `Receiving_ModeSelectionView.xaml` in `Views/Receiving/`

Services, DAOs, and Models already exist from feature `007-architecture-compliance` and will be reused without modification.

**File Count**: 
- **New files**: 30 (15 XAML views + 15 C# ViewModels in Views/Dunnage and ViewModels/Dunnage folders)
- **Existing files (no changes)**: 2 (Main_DunnageLabelPage.xaml, Main_DunnageLabelViewModel.cs)
- **Modified files**: 1 (App.xaml.cs for DI registration of 8 new ViewModels)
- **Existing files reused**: 9 (3 Services + 3 DAOs + 3 Models)

## Receiving Workflow Pattern Reference

**Pattern Source**: `Views/Receiving/Receiving_ManualEntryView.xaml` and `Views/Receiving/Receiving_EditModeView.xaml`

The Dunnage Manual Entry and Edit Mode views MUST follow the established patterns from the Receiving workflow:

### Manual Entry View Pattern

**XAML Structure** (`Dunnage_ManualEntryView.xaml`):
- **Grid with 3 rows**: Toolbar (Auto), DataGrid (*), Navigation (Auto)
- **Toolbar (Row 0)**: Left column with operations, right column with "Mode Selection" button
  - Operations: Add Row, Add Multiple, Remove Row, Auto-Fill, Fill Blank Spaces, Sort
- **DataGrid (Row 1)**: CommunityToolkit DataGrid with:
  - `KeyDown` event → `DataGrid_KeyDown`
  - `CurrentCellChanged` event → `DataGrid_CurrentCellChanged`
  - `Tapped` event → `DataGrid_Tapped`
  - Columns: Type (ComboBox), Part (ComboBox), Quantity, Weight/Qty, Heat/Lot, PO, Location, Specs
- **Navigation (Row 2)**: Save & Finish button (right-aligned)

**Code-Behind Pattern** (`Dunnage_ManualEntryView.xaml.cs`):
```csharp
public sealed partial class Dunnage_ManualEntryView : UserControl
{
    public Dunnage_ManualEntryViewModel ViewModel { get; }

    public Dunnage_ManualEntryView()
    {
        ViewModel = App.GetService<Dunnage_ManualEntryViewModel>();
        this.DataContext = ViewModel;
        this.InitializeComponent();
        
        // Listen for collection changes to handle "Add Row" focus
        ViewModel.Loads.CollectionChanged += Loads_CollectionChanged;
    }

    private void Loads_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        // Auto-focus and edit first cell of new row
        if (e.Action == NotifyCollectionChangedAction.Add)
        {
            ManualEntryDataGrid.DispatcherQueue.TryEnqueue(() =>
            {
                var newItem = e.NewItems?[0] as Model_DunnageLoad;
                if (newItem != null)
                {
                    ManualEntryDataGrid.SelectedItem = newItem;
                    ManualEntryDataGrid.ScrollIntoView(newItem, ManualEntryDataGrid.Columns.FirstOrDefault());
                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(100); // Grid render delay
                        ManualEntryDataGrid.DispatcherQueue.TryEnqueue(() =>
                        {
                            SelectFirstEditableCell(ManualEntryDataGrid);
                        });
                    });
                }
            });
        }
    }

    private void ManualEntryDataGrid_CurrentCellChanged(object? sender, EventArgs e)
    {
        var grid = sender as DataGrid;
        if (grid?.CurrentColumn != null && !grid.CurrentColumn.IsReadOnly)
        {
            grid.DispatcherQueue.TryEnqueue(() => grid.BeginEdit());
        }
    }

    private void ManualEntryDataGrid_KeyDown(object sender, KeyRoutedEventArgs e)
    {
        // Handle Tab, Enter, Escape for grid navigation
    }

    private void ManualEntryDataGrid_Tapped(object sender, TappedRoutedEventArgs e)
    {
        // Handle cell selection and edit mode activation
    }

    private void SelectFirstEditableCell(DataGrid grid)
    {
        // Focus first editable column
    }
}
```

**ViewModel Pattern** (`Dunnage_ManualEntryViewModel.cs`):
- **Properties**: `ObservableCollection<Model_DunnageLoad> Loads`, `SelectedLoad`, `CanSave`
- **Commands**:
  - `AddRowCommand` → Creates new `Model_DunnageLoad` with defaults, adds to collection
  - `AddMultipleCommand(string countStr)` → Validates count (1-100), adds N rows
  - `RemoveRowCommand` → Removes selected row
  - `AutoFillCommand` → Fetches last entry for same Part ID, copies PO/Location/Specs
  - `FillBlankSpacesCommand` → Copies PO/Location/Specs from last row to empty fields
  - `SortForPrintingCommand` → Sorts by Part ID (asc) → PO (asc) → Type (asc)
  - `SaveToHistoryCommand` → Saves with `Status="In Progress"`
  - `SaveAllCommand` → Saves with `Status="Complete"`, exports CSV
- **Initialization**: Constructor injects services, `InitializeAsync()` loads types/parts

### Edit Mode View Pattern

**XAML Structure** (`Dunnage_EditModeView.xaml`):
- **Grid with 4 rows**: Toolbar (Auto), Date Filter (Auto), DataGrid (*), Footer (Auto)
- **Toolbar (Row 0)**: Load from Memory/Labels/History buttons, Select All, Remove Row
- **Date Filter (Row 1)**: CalendarDatePickers + quick buttons (Today, This Week, This Month, This Quarter)
- **DataGrid (Row 2)**: Same event handlers as Manual Entry
- **Footer (Row 3)**: Left = Pagination controls, Right = Save & Export buttons

**Code-Behind Pattern** (`Dunnage_EditModeView.xaml.cs`):
- Same as Manual Entry (DataGrid events, focus management)

**ViewModel Pattern** (`Dunnage_EditModeViewModel.cs`):
- **Properties**: 
  - `ObservableCollection<Model_DunnageLoad> Loads` (paged display)
  - `List<Model_DunnageLoad> _allLoads`, `_filteredLoads` (internal)
  - `FilterStartDate`, `FilterEndDate`
  - `CurrentPage`, `TotalPages`, `GotoPageNumber`
  - `CurrentDataSource` (Memory, Labels, History)
- **Commands**:
  - `LoadFromCurrentMemoryCommand` → Loads from workflow session
  - `LoadFromCurrentLabelsCommand` → Loads from CSV export folder
  - `LoadFromHistoryCommand` → Loads from database by date range
  - `SelectAllCommand` → Toggles `IsSelected` on all displayed loads
  - `RemoveRowCommand` → Soft delete (tracks in `_deletedLoads`)
  - `SaveAllCommand` → Persists changes, hard deletes tracked items
  - Pagination: `FirstPageCommand`, `PreviousPageCommand`, `NextPageCommand`, `LastPageCommand`, `GotoPageCommand`
- **Pagination**: Uses `IService_Pagination` with 50 rows per page
- **Date Filtering**: `OnFilterStartDateChanged`, `OnFilterEndDateChanged` → `ApplyDateFilter()`

### Required Converters

- `Converter_DecimalToString` - Displays decimal values in DataGrid cells
- Use existing converters from `Converters/` folder

### DataGrid Column Patterns

**Manual Entry Columns**:
1. `IsSelected` (CheckBox) - only in Edit Mode
2. `LoadNumber` (Text, ReadOnly) - auto-generated
3. `Type` (ComboBox) - editable, bound to `AvailableTypes`
4. `PartID` (ComboBox) - editable, bound to `AvailableParts` filtered by Type
5. `Quantity` (NumberBox) - editable, Minimum=1
6. `Weight/Qty` (NumberBox with Converter_DecimalToString) - editable
7. `Heat/Lot` (Text) - editable
8. `PO` (Text) - editable
9. `Location` (Text) - editable
10. Dynamic specs (Text/NumberBox/CheckBox) - based on type schema

**Edit Mode Additional Columns**:
- `CreatedDate` (DateOnly, ReadOnly)
- `CreatedBy` (Text, ReadOnly)
- `Status` (Text, ReadOnly) - "In Progress" or "Complete"

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |
| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |
