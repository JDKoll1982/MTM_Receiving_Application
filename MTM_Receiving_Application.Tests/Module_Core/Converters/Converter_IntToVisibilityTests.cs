// <auto-generated>
// This test file was generated by GitHub Copilot
// Generation Date: 2025-01-19
// Source File: Module_Core/Converters/Converter_IntToVisibility.cs
// </auto-generated>

using FluentAssertions;
using Microsoft.UI.Xaml;
using MTM_Receiving_Application.Module_Core.Converters;
using Xunit;

namespace MTM_Receiving_Application.Tests.Module_Core.Converters;

/// <summary>
/// Unit tests for <see cref="Converter_IntToVisibility"/>.
/// Tests conversion of integer values to Visibility with support for comparison, inverse, and positive value modes.
/// </summary>
[Trait("Category", "Unit")]
[Trait("Layer", "Converter")]
[Trait("Module", "Module_Core")]
public class Converter_IntToVisibilityTests
{
    private readonly Converter_IntToVisibility _sut;

    public Converter_IntToVisibilityTests()
    {
        _sut = new Converter_IntToVisibility();
    }

    [Fact]
    public void Convert_PositiveIntWithoutParameter_ReturnsVisible()
    {
        var result = _sut.Convert(5, typeof(Visibility), null, "en-US");

        result.Should().Be(Visibility.Visible);
    }

    [Fact]
    public void Convert_ZeroWithoutParameter_ReturnsCollapsed()
    {
        var result = _sut.Convert(0, typeof(Visibility), null, "en-US");

        result.Should().Be(Visibility.Collapsed);
    }

    [Fact]
    public void Convert_NegativeIntWithoutParameter_ReturnsCollapsed()
    {
        var result = _sut.Convert(-5, typeof(Visibility), null, "en-US");

        result.Should().Be(Visibility.Collapsed);
    }

    [Fact]
    public void Convert_ZeroWithInverseParameter_ReturnsVisible()
    {
        var result = _sut.Convert(0, typeof(Visibility), "Inverse", "en-US");

        result.Should().Be(Visibility.Visible);
    }

    [Fact]
    public void Convert_PositiveIntWithInverseParameter_ReturnsCollapsed()
    {
        var result = _sut.Convert(5, typeof(Visibility), "Inverse", "en-US");

        result.Should().Be(Visibility.Collapsed);
    }

    [Theory]
    [InlineData(1, "1", Visibility.Visible)]
    [InlineData(2, "2", Visibility.Visible)]
    [InlineData(1, "2", Visibility.Collapsed)]
    [InlineData(5, "5", Visibility.Visible)]
    public void Convert_WithNumericStringParameter_ComparesValueToParameter(int value, string parameter, Visibility expected)
    {
        var result = _sut.Convert(value, typeof(Visibility), parameter, "en-US");

        result.Should().Be(expected);
    }

    [Theory]
    [InlineData(1, 1, Visibility.Visible)]
    [InlineData(2, 2, Visibility.Visible)]
    [InlineData(1, 2, Visibility.Collapsed)]
    public void Convert_WithIntParameter_ComparesValueToParameter(int value, int parameter, Visibility expected)
    {
        var result = _sut.Convert(value, typeof(Visibility), parameter, "en-US");

        result.Should().Be(expected);
    }

    [Fact]
    public void Convert_NullValue_ReturnsCollapsed()
    {
        var result = _sut.Convert(null, typeof(Visibility), null, "en-US");

        result.Should().Be(Visibility.Collapsed);
    }

    [Fact]
    public void Convert_NonIntValue_ReturnsCollapsed()
    {
        var result = _sut.Convert("not an int", typeof(Visibility), null, "en-US");

        result.Should().Be(Visibility.Collapsed);
    }

    [Fact]
    public void Convert_WithUnknownStringParameter_FallsBackToPositiveCheck()
    {
        var result = _sut.Convert(5, typeof(Visibility), "UnknownParam", "en-US");

        result.Should().Be(Visibility.Visible);
    }

    [Fact]
    public void ConvertBack_ThrowsNotImplementedException()
    {
        var act = () => _sut.ConvertBack(Visibility.Visible, typeof(int), null, "en-US");

        act.Should().Throw<NotImplementedException>();
    }
}
