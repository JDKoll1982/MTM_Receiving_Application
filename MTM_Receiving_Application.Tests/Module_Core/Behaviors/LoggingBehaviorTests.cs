// <auto-generated>
// This test file was generated by GitHub Copilot
// Generation Date: 2025-01-19
// Source File: Module_Core/Behaviors/LoggingBehavior.cs
// </auto-generated>

#nullable enable

using FluentAssertions;
using MediatR;
using Microsoft.Extensions.Logging;
using Moq;
using MTM_Receiving_Application.Module_Core.Behaviors;
using Xunit;

namespace MTM_Receiving_Application.Tests.Module_Core.Behaviors;

/// <summary>
/// Unit tests for LoggingBehavior pipeline behavior.
/// Tests that all MediatR requests are logged with timing information.
/// </summary>
[Trait("Category", "Unit")]
[Trait("Layer", "Behavior")]
[Trait("Module", "Module_Core")]
public class LoggingBehaviorTests
{
    private readonly Mock<ILogger<LoggingBehavior<TestRequest, TestResponse>>> _mockLogger;

    public LoggingBehaviorTests()
    {
        _mockLogger = new Mock<ILogger<LoggingBehavior<TestRequest, TestResponse>>>();
    }

    private LoggingBehavior<TestRequest, TestResponse> CreateLoggingBehavior()
    {
        return new LoggingBehavior<TestRequest, TestResponse>(_mockLogger.Object);
    }

    [Fact]
    public async Task Handle_ShouldLogRequestStart_WhenProcessingRequest()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var expectedResponse = new TestResponse { Success = true };
        var cancellationToken = CancellationToken.None;

        RequestHandlerDelegate<TestResponse> next = (_) => Task.FromResult(expectedResponse);

        await loggingBehavior.Handle(request, next, cancellationToken);

        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("Handling") && v.ToString()!.Contains("TestRequest")),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }

    [Fact]
    public async Task Handle_ShouldLogRequestCompletion_WithElapsedTime()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var expectedResponse = new TestResponse { Success = true };
        var cancellationToken = CancellationToken.None;

        RequestHandlerDelegate<TestResponse> next = async (_) =>
        {
            await Task.Delay(10); // Simulate some processing time
            return expectedResponse;
        };

        await loggingBehavior.Handle(request, next, cancellationToken);

        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("Handled") && v.ToString()!.Contains("TestRequest")),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }

    [Fact]
    public async Task Handle_ShouldIncludeRequestGuid_InBothStartAndCompletionLogs()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var expectedResponse = new TestResponse { Success = true };
        var cancellationToken = CancellationToken.None;

        RequestHandlerDelegate<TestResponse> next = (_) => Task.FromResult(expectedResponse);

        await loggingBehavior.Handle(request, next, cancellationToken);

        // Should have exactly 2 log calls (start and completion)
        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.IsAny<It.IsAnyType>(),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Exactly(2));
    }

    [Fact]
    public async Task Handle_ShouldCallNextDelegate_AndReturnResponse()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var expectedResponse = new TestResponse { Success = true };
        var cancellationToken = CancellationToken.None;
        var nextCalled = false;

        RequestHandlerDelegate<TestResponse> nextDelegate = (_) =>
        {
            nextCalled = true;
            return Task.FromResult(expectedResponse);
        };

        var result = await loggingBehavior.Handle(request, nextDelegate, cancellationToken);

        nextCalled.Should().BeTrue();
        result.Should().Be(expectedResponse);
    }

    [Fact]
    public async Task Handle_ShouldLogError_WhenNextThrowsException()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var cancellationToken = CancellationToken.None;
        var expectedException = new InvalidOperationException("Handler failed");

        RequestHandlerDelegate<TestResponse> nextDelegate = (_) => throw expectedException;

        var act = async () => await loggingBehavior.Handle(request, nextDelegate, cancellationToken);
        await act.Should().ThrowAsync<InvalidOperationException>().WithMessage("Handler failed");

        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Error,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("Error handling") && v.ToString()!.Contains("TestRequest")),
                It.IsAny<InvalidOperationException>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }

    [Fact]
    public async Task Handle_ShouldIncludeExceptionMessage_InErrorLog()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var cancellationToken = CancellationToken.None;
        var expectedException = new ArgumentException("Invalid argument supplied");

        RequestHandlerDelegate<TestResponse> nextDelegate = (_) => throw expectedException;

        var act = async () => await loggingBehavior.Handle(request, nextDelegate, cancellationToken);
        await act.Should().ThrowAsync<ArgumentException>();

        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Error,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("Invalid argument supplied")),
                It.IsAny<ArgumentException>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }

    [Fact]
    public async Task Handle_ShouldPropagateException_AfterLogging()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var cancellationToken = CancellationToken.None;
        var expectedException = new NotSupportedException("Operation not supported");

        RequestHandlerDelegate<TestResponse> nextDelegate = (_) => throw expectedException;

        var act = async () => await loggingBehavior.Handle(request, nextDelegate, cancellationToken);

        await act.Should().ThrowAsync<NotSupportedException>().WithMessage("Operation not supported");
    }

    [Fact]
    public async Task Handle_ShouldMeasureExecutionTime_AndIncludeInLogs()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var expectedResponse = new TestResponse { Success = true };
        var cancellationToken = CancellationToken.None;

        RequestHandlerDelegate<TestResponse> next = async (_) =>
        {
            await Task.Delay(50); // Simulate 50ms processing
            return expectedResponse;
        };

        await loggingBehavior.Handle(request, next, cancellationToken);

        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("ms")),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.AtLeastOnce);
    }

    [Fact]
    public async Task Handle_ShouldHandleCancellation_AndLogAppropriately()
    {
        var loggingBehavior = CreateLoggingBehavior();
        var request = new TestRequest { Data = "test data" };
        var expectedResponse = new TestResponse { Success = true };
        using var cts = new CancellationTokenSource();

        RequestHandlerDelegate<TestResponse> next = (_) => Task.FromResult(expectedResponse);

        var result = await loggingBehavior.Handle(request, next, cts.Token);

        result.Should().Be(expectedResponse);
        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.IsAny<It.IsAnyType>(),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Exactly(2));
    }

    #region Test Types

    /// <summary>
    /// Test request type for LoggingBehavior testing.
    /// </summary>
    public record TestRequest : IRequest<TestResponse>
    {
        public string Data { get; init; } = string.Empty;
    }

    /// <summary>
    /// Test response type for LoggingBehavior testing.
    /// </summary>
    public record TestResponse
    {
        public bool Success { get; init; }
    }

    #endregion
}
