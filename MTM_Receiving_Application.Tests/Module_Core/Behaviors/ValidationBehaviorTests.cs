// <auto-generated>
// This test file was generated by GitHub Copilot
// Generation Date: 2025-01-19
// Source File: Module_Core/Behaviors/ValidationBehavior.cs
// </auto-generated>

#nullable enable

using FluentAssertions;
using FluentValidation;
using FluentValidation.Results;
using MediatR;
using Moq;
using MTM_Receiving_Application.Module_Core.Behaviors;
using Xunit;

namespace MTM_Receiving_Application.Tests.Module_Core.Behaviors;

/// <summary>
/// Unit tests for ValidationBehavior pipeline behavior.
/// Tests that FluentValidation is applied to all commands before handler execution.
/// </summary>
[Trait("Category", "Unit")]
[Trait("Layer", "Behavior")]
[Trait("Module", "Module_Core")]
public class ValidationBehaviorTests
{
    private ValidationBehavior<TestCommand, TestCommandResponse> CreateValidationBehavior(
        IEnumerable<IValidator<TestCommand>>? validators = null)
    {
        validators ??= [];
        return new ValidationBehavior<TestCommand, TestCommandResponse>(validators);
    }

    [Fact]
    public async Task Handle_WithNoValidators_ShouldCallNext()
    {
        var behavior = CreateValidationBehavior();
        var command = new TestCommand { Value = "valid" };
        var expectedResponse = new TestCommandResponse { Success = true };
        var nextCalled = false;

        RequestHandlerDelegate<TestCommandResponse> next = (_) =>
        {
            nextCalled = true;
            return Task.FromResult(expectedResponse);
        };

        var result = await behavior.Handle(command, next, CancellationToken.None);

        nextCalled.Should().BeTrue();
        result.Should().Be(expectedResponse);
    }

    [Fact]
    public async Task Handle_WithValidRequest_ShouldCallNext()
    {
        var mockValidator = new Mock<IValidator<TestCommand>>();
        var validationResult = new ValidationResult();
        mockValidator
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(validationResult);

        var behavior = CreateValidationBehavior([mockValidator.Object]);
        var command = new TestCommand { Value = "valid" };
        var expectedResponse = new TestCommandResponse { Success = true };
        var nextCalled = false;

        RequestHandlerDelegate<TestCommandResponse> next = (_) =>
        {
            nextCalled = true;
            return Task.FromResult(expectedResponse);
        };

        var result = await behavior.Handle(command, next, CancellationToken.None);

        nextCalled.Should().BeTrue();
        result.Should().Be(expectedResponse);
    }

    [Fact]
    public async Task Handle_WithValidationFailure_ShouldThrowValidationException()
    {
        var mockValidator = new Mock<IValidator<TestCommand>>();
        var failures = new[]
        {
            new ValidationFailure("Value", "Value is required")
        };
        var validationResult = new ValidationResult(failures);
        
        mockValidator
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(validationResult);

        var behavior = CreateValidationBehavior([mockValidator.Object]);
        var command = new TestCommand { Value = "" };

        RequestHandlerDelegate<TestCommandResponse> next = (_) =>
            throw new InvalidOperationException("Handler should not be called");

        var act = async () => await behavior.Handle(command, next, CancellationToken.None);

        await act.Should().ThrowAsync<ValidationException>();
    }

    [Fact]
    public async Task Handle_WithMultipleValidators_ShouldRunAllInParallel()
    {
        var mockValidator1 = new Mock<IValidator<TestCommand>>();
        var mockValidator2 = new Mock<IValidator<TestCommand>>();
        
        var result1 = new ValidationResult();
        var result2 = new ValidationResult();

        mockValidator1
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(result1);

        mockValidator2
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(result2);

        var behavior = CreateValidationBehavior([mockValidator1.Object, mockValidator2.Object]);
        var command = new TestCommand { Value = "valid" };
        var expectedResponse = new TestCommandResponse { Success = true };

        RequestHandlerDelegate<TestCommandResponse> next = (_) => Task.FromResult(expectedResponse);

        var result = await behavior.Handle(command, next, CancellationToken.None);

        result.Should().Be(expectedResponse);
        mockValidator1.Verify(
            v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()),
            Times.Once);
        mockValidator2.Verify(
            v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()),
            Times.Once);
    }

    [Fact]
    public async Task Handle_WithMultipleValidationFailures_ShouldThrowValidationExceptionWithAllFailures()
    {
        var mockValidator = new Mock<IValidator<TestCommand>>();
        var failures = new[]
        {
            new ValidationFailure("Value", "Value is required"),
            new ValidationFailure("Length", "Value must be at least 5 characters")
        };
        var validationResult = new ValidationResult(failures);

        mockValidator
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(validationResult);

        var behavior = CreateValidationBehavior([mockValidator.Object]);
        var command = new TestCommand { Value = "" };

        RequestHandlerDelegate<TestCommandResponse> next = (_) =>
            throw new InvalidOperationException("Handler should not be called");

        var act = async () => await behavior.Handle(command, next, CancellationToken.None);

        var exception = await act.Should().ThrowAsync<ValidationException>();
        exception.Which.Errors.Count().Should().Be(2);
    }

    [Fact]
    public async Task Handle_WithMultipleValidators_AndMultipleFailures_ShouldAggregateAllErrors()
    {
        var mockValidator1 = new Mock<IValidator<TestCommand>>();
        var mockValidator2 = new Mock<IValidator<TestCommand>>();

        var failures1 = new[] { new ValidationFailure("Value", "Error 1") };
        var failures2 = new[] { new ValidationFailure("Length", "Error 2") };

        mockValidator1
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new ValidationResult(failures1));

        mockValidator2
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new ValidationResult(failures2));

        var behavior = CreateValidationBehavior([mockValidator1.Object, mockValidator2.Object]);
        var command = new TestCommand { Value = "" };

        RequestHandlerDelegate<TestCommandResponse> next = (_) =>
            throw new InvalidOperationException("Handler should not be called");

        var act = async () => await behavior.Handle(command, next, CancellationToken.None);

        var exception = await act.Should().ThrowAsync<ValidationException>();
        exception.Which.Errors.Count().Should().Be(2);
    }

    [Fact]
    public async Task Handle_ShouldNotCallNext_WhenValidationFails()
    {
        var mockValidator = new Mock<IValidator<TestCommand>>();
        var failures = new[] { new ValidationFailure("Value", "Value is invalid") };
        var validationResult = new ValidationResult(failures);

        mockValidator
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(validationResult);

        var behavior = CreateValidationBehavior([mockValidator.Object]);
        var command = new TestCommand { Value = "" };
        var nextCalled = false;

        RequestHandlerDelegate<TestCommandResponse> next = (_) =>
        {
            nextCalled = true;
            throw new InvalidOperationException("Handler should not be called");
        };

        var act = async () => await behavior.Handle(command, next, CancellationToken.None);

        await act.Should().ThrowAsync<ValidationException>();
        nextCalled.Should().BeFalse();
    }

    [Fact]
    public async Task Handle_WithCancellationToken_ShouldPassToValidators()
    {
        var mockValidator = new Mock<IValidator<TestCommand>>();
        var validationResult = new ValidationResult();

        mockValidator
            .Setup(v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(validationResult);

        var behavior = CreateValidationBehavior([mockValidator.Object]);
        var command = new TestCommand { Value = "valid" };
        using var cts = new CancellationTokenSource();

        RequestHandlerDelegate<TestCommandResponse> next = (_) => Task.FromResult(new TestCommandResponse { Success = true });

        await behavior.Handle(command, next, cts.Token);

        mockValidator.Verify(
            v => v.ValidateAsync(It.IsAny<ValidationContext<TestCommand>>(), cts.Token),
            Times.Once);
    }

    [Fact]
    public async Task Handle_WithEmptyValidatorList_ShouldSkipValidationAndCallNext()
    {
        var behavior = CreateValidationBehavior([]);
        var command = new TestCommand { Value = "" };
        var expectedResponse = new TestCommandResponse { Success = true };
        var nextCalled = false;

        RequestHandlerDelegate<TestCommandResponse> next = (_) =>
        {
            nextCalled = true;
            return Task.FromResult(expectedResponse);
        };

        var result = await behavior.Handle(command, next, CancellationToken.None);

        nextCalled.Should().BeTrue();
        result.Should().Be(expectedResponse);
    }

    #region Test Types

    /// <summary>
    /// Test command type for ValidationBehavior testing.
    /// </summary>
    public record TestCommand : IRequest<TestCommandResponse>
    {
        public string Value { get; init; } = string.Empty;
    }

    /// <summary>
    /// Test response type for ValidationBehavior testing.
    /// </summary>
    public record TestCommandResponse
    {
        public bool Success { get; init; }
    }

    #endregion
}
