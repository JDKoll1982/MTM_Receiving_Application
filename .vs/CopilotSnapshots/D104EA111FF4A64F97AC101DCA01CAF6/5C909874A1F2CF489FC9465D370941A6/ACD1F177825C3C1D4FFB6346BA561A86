<#
.SYNOPSIS
    Adds the 'Async' suffix to asynchronous methods in a C# file that are missing it.

.DESCRIPTION
    This script parses a C# file for method declarations that use the 'async' modifier 
    and return 'Task' or 'ValueTask', but do not end with the 'Async' suffix. 
    It renames the method definition in place.
    
    WARNING: This script performs regex-based text replacement. It updates method 
    definitions but DOES NOT parse or update references (call sites) to these methods.
    Review changes carefully or use an IDE refactoring tool for complete rename.

.PARAMETER FilePath
    Path to the C# file to process.

.EXAMPLE
    .\Add-AsyncSuffix.ps1 -FilePath "..\Services\MyService.cs" -WhatIf
    Shows which methods would be renamed without modifying the file.

.EXAMPLE
    .\Add-AsyncSuffix.ps1 -FilePath "..\Services\MyService.cs"
    Renames the methods in the file.
#>
[CmdletBinding(SupportsShouldProcess=$true)]
param (
    [Parameter(Mandatory=$true, HelpMessage="Path to the C# file to process")]
    [ValidateScript({Test-Path $_ -PathType Leaf})]
    [string]$FilePath
)

# Read the file content
$originalContent = Get-Content -Path $FilePath -Raw
$newContent = $originalContent

# Regex to find async method definitions
# Matches: async keyword, arbitrary return type characters (must contain Task/ValueTask), MethodName, paren
# We use a broad match for the return type to handle nested generics like Task<List<string>>
# Pattern details:
# 1. \b(async) ... : Start with async
# 2. [\w\s<>,\[\]]*? : Non-greedy match of type characters
# 3. (?:Task|ValueTask) : Must contain Task or ValueTask
# 4. [\w\s<>,\[\]]*? : More type characters
# 5. \s+ : Space before method name
# 6. (\w+) : Method name
# 7. (?<!Async) : Negative lookbehind, method name must not end in Async
# 8. \s*\( : Opening parenthesis
$pattern = '(\basync\s+[\w\s<>,\[\]]*?(?:Task|ValueTask)[\w\s<>,\[\]]*?\s+)(\w+)(?<!Async)(\s*\()'

$matches = [regex]::Matches($originalContent, $pattern, "ExplicitCapture")

if ($matches.Count -eq 0) {
    Write-Host "No async methods missing suffix found in '$FilePath'." -ForegroundColor Gray
    return
}

Write-Host "Found $($matches.Count) method(s) to rename in '$FilePath'." -ForegroundColor Cyan

foreach ($match in $matches) {
    $fullHeader = $match.Value
    $prefix = $match.Groups[1].Value
    $methodName = $match.Groups[2].Value
    $suffix = $match.Groups[3].Value
    
    $newMethodName = "${methodName}Async"
    $newHeader = "${prefix}${newMethodName}${suffix}"
    
    if ($PSCmdlet.ShouldProcess("Method '$methodName'", "Rename to '$newMethodName'")) {
        # Perform replacement
        # Note: Simple Replace might replace occurrences elsewhere if headers are identical duplicates (unlikely for headers)
        # We use strict substitution for the specific match index would be safer, 
        # but regex command typically rebuilds the string. 
        
        # Simpler approach allows regex replace global if the header is unique enough.
        # However, to be robust, we'll re-run the regex replace on the variable so far.
        
        # Using [regex]::Replace with a MatchEvaluator to modify only if needed?
        # Since we are iterating matches, let's do a single pass replace.
    }
}

# Apply changes if we are processing real run
if ($PSCmdlet.ShouldProcess($FilePath, "Save changes to file")) {
    $evaluator = { param($m) 
        $existingName = $m.Groups[2].Value
        # Double check negative lookbehind in case logic varies, but regex handles it.
        $newName = "${existingName}Async"
        Write-Host "  Renaming '$existingName' -> '$newName'" -ForegroundColor Green
        return $m.Groups[1].Value + $newName + $m.Groups[3].Value
    }
    
    $finalContent = [regex]::Replace($originalContent, $pattern, $evaluator)
    
    if ($finalContent -ne $originalContent) {
        Set-Content -Path $FilePath -Value $finalContent -Encoding UTF8
        Write-Host "File saved." -ForegroundColor Green
    }
}
